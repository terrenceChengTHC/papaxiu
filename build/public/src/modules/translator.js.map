{"version":3,"sources":["public/src/modules/translator.js"],"names":["factory","loadClient","language","namespace","Promise","resolve","jQuery","getJSON","config","relative_path","warn","environment","console","bind","define","amd","string","module","exports","languages","require","global","env","winston","a","loadServer","reject","get","err","data","window","translator","load","assign","Object","extend","classCallCheck","instance","Constructor","TypeError","Translator","self","this","modules","keys","moduleFactories","map","reduce","prev","elem","lang","translations","prototype","translate","str","validText","validTextRegex","RegExp","invalidTextRegex","cursor","lastBreak","len","length","toTranslate","inToken","split","text","arr","i","brk","level","slice","push","trim","sliced","textBeforeColonFound","colonFound","textAfterColonFound","commaAfterNameFound","test","currentSlice","result","name","args","backup","translateKey","last","all","then","translated","join","key","translation","getTranslation","argsToTranslate","arg","collapseWhitespace","decodeHTMLEntities","escapeHTML","s","replace","translatedArgs","out","forEach","escaped","catch","x","descendantTextNodes","node","textNodes","helper","nodeType","c","childNodes","l","translateInPlace","element","attributes","nodes","nodeValue","attrNodes","attr","tuples","Array","call","querySelectorAll","el","concat","attrText","getAttribute","ref","translatedAttrs","html","$","replaceWith","setAttribute","getLanguage","utils","params","userLang","defaultLang","meta","create","cache","registerModule","removePatterns","sub","escape","unescape","compile","arguments","adaptor","callback","cb","String","stack","output","error","addTranslation","getTranslations","toggleTimeagoShorthand","tmp","timeago","settings","strings","timeagoShort","prepareDOM","languageCode","userLangToTimeagoCode","getScript","done","value","css"],"mappings":"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","file":"public/src/modules/translator.js","sourcesContent":["'use strict';\n\n(function (factory) {\n\tfunction loadClient(language, namespace) {\n\t\treturn Promise.resolve(jQuery.getJSON(config.relative_path + '/assets/language/' + language + '/' + namespace + '.json?' + config['cache-buster']));\n\t}\n\tvar warn = function () {};\n\tif (typeof config === 'object' && config.environment === 'development') {\n\t\twarn = console.warn.bind(console);\n\t}\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as a named module\n\t\tdefine('translator', ['string'], function (string) {\n\t\t\treturn factory(string, loadClient, warn);\n\t\t});\n\t} else if (typeof module === 'object' && module.exports) {\n\t\t// Node\n\t\t(function () {\n\t\t\tvar languages = require('../../../src/languages');\n\n\t\t\tif (global.env === 'development') {\n\t\t\t\tvar winston = require('winston');\n\t\t\t\twarn = function (a) {\n\t\t\t\t\twinston.warn(a);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction loadServer(language, namespace) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tlanguages.get(language, namespace, function (err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tmodule.exports = factory(require('string'), loadServer, warn);\n\t\t}());\n\t} else {\n\t\twindow.translator = factory(window.string, loadClient, warn);\n\t}\n}(function (string, load, warn) {\n\tvar assign = Object.assign || jQuery.extend;\n\tfunction classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n\tvar Translator = (function () {\n\t\t/**\n\t\t * Construct a new Translator object\n\t\t * @param {string} language - Language code for this translator instance\n\t\t * @exports translator.Translator\n\t\t */\n\t\tfunction Translator(language) {\n\t\t\tvar self = this;\n\t\t\tclassCallCheck(self, Translator);\n\n\t\t\tif (!language) {\n\t\t\t\tthrow new TypeError('Parameter `language` must be a language string. Received ' + language + (language === '' ? '(empty string)' : ''));\n\t\t\t}\n\n\t\t\tself.modules = Object.keys(Translator.moduleFactories).map(function (namespace) {\n\t\t\t\tvar factory = Translator.moduleFactories[namespace];\n\t\t\t\treturn [namespace, factory(language)];\n\t\t\t}).reduce(function (prev, elem) {\n\t\t\t\tvar namespace = elem[0];\n\t\t\t\tvar module = elem[1];\n\t\t\t\tprev[namespace] = module;\n\n\t\t\t\treturn prev;\n\t\t\t}, {});\n\n\t\t\tself.lang = language;\n\t\t\tself.translations = {};\n\t\t}\n\n\t\tTranslator.prototype.load = load;\n\n\t\t/**\n\t\t * Parse the translation instructions into the language of the Translator instance\n\t\t * @param {string} str - Source string\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tTranslator.prototype.translate = function translate(str) {\n\t\t\t// regex for valid text in namespace / key\n\t\t\tvar validText = 'a-zA-Z0-9\\\\-_.\\\\/';\n\t\t\tvar validTextRegex = new RegExp('[' + validText + ']');\n\t\t\tvar invalidTextRegex = new RegExp('[^' + validText + '\\\\]]');\n\n\t\t\t// current cursor position\n\t\t\tvar cursor = 0;\n\t\t\t// last break of the input string\n\t\t\tvar lastBreak = 0;\n\t\t\t// length of the input string\n\t\t\tvar len = str.length;\n\t\t\t// array to hold the promises for the translations\n\t\t\t// and the strings of untranslated text in between\n\t\t\tvar toTranslate = [];\n\n\t\t\t// to store the state of if we're currently in a top-level token for later\n\t\t\tvar inToken = false;\n\n\t\t\t// split a translator string into an array of tokens\n\t\t\t// but don't split by commas inside other translator strings\n\t\t\tfunction split(text) {\n\t\t\t\tvar len = text.length;\n\t\t\t\tvar arr = [];\n\t\t\t\tvar i = 0;\n\t\t\t\tvar brk = 0;\n\t\t\t\tvar level = 0;\n\n\t\t\t\twhile (i + 2 <= len) {\n\t\t\t\t\tif (text.slice(i, i + 2) === '[[') {\n\t\t\t\t\t\tlevel += 1;\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else if (text.slice(i, i + 2) === ']]') {\n\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t} else if (level === 0 && text[i] === ',' && text[i - 1] !== '\\\\') {\n\t\t\t\t\t\tarr.push(text.slice(brk, i).trim());\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tbrk = i;\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t\tarr.push(text.slice(brk, i + 1).trim());\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\t// the loooop, we'll go to where the cursor\n\t\t\t// is equal to the length of the string since\n\t\t\t// slice doesn't include the ending index\n\t\t\twhile (cursor + 2 <= len) {\n\t\t\t\t// if the current position in the string looks\n\t\t\t\t// like the beginning of a translation string\n\t\t\t\tif (str.slice(cursor, cursor + 2) === '[[') {\n\t\t\t\t\t// split the string from the last break\n\t\t\t\t\t// to the character before the cursor\n\t\t\t\t\t// add that to the result array\n\t\t\t\t\ttoTranslate.push(str.slice(lastBreak, cursor));\n\t\t\t\t\t// set the cursor position past the beginning\n\t\t\t\t\t// brackets of the translation string\n\t\t\t\t\tcursor += 2;\n\t\t\t\t\t// set the last break to our current\n\t\t\t\t\t// spot since we just broke the string\n\t\t\t\t\tlastBreak = cursor;\n\t\t\t\t\t// we're in a token now\n\t\t\t\t\tinToken = true;\n\n\t\t\t\t\t// the current level of nesting of the translation strings\n\t\t\t\t\tvar level = 0;\n\t\t\t\t\tvar sliced;\n\t\t\t\t\t// validating the current string is actually a translation\n\t\t\t\t\tvar textBeforeColonFound = false;\n\t\t\t\t\tvar colonFound = false;\n\t\t\t\t\tvar textAfterColonFound = false;\n\t\t\t\t\tvar commaAfterNameFound = false;\n\n\t\t\t\t\twhile (cursor + 2 <= len) {\n\t\t\t\t\t\tsliced = str.slice(cursor, cursor + 2);\n\t\t\t\t\t\t// found some text after the double bracket,\n\t\t\t\t\t\t// so this is probably a translation string\n\t\t\t\t\t\tif (!textBeforeColonFound && validTextRegex.test(sliced[0])) {\n\t\t\t\t\t\t\ttextBeforeColonFound = true;\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t// found a colon, so this is probably a translation string\n\t\t\t\t\t\t} else if (textBeforeColonFound && !colonFound && sliced[0] === ':') {\n\t\t\t\t\t\t\tcolonFound = true;\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t// found some text after the colon,\n\t\t\t\t\t\t// so this is probably a translation string\n\t\t\t\t\t\t} else if (colonFound && !textAfterColonFound && validTextRegex.test(sliced[0])) {\n\t\t\t\t\t\t\ttextAfterColonFound = true;\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t} else if (textAfterColonFound && !commaAfterNameFound && sliced[0] === ',') {\n\t\t\t\t\t\t\tcommaAfterNameFound = true;\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t// a space or comma was found before the name\n\t\t\t\t\t\t// this isn't a translation string, so back out\n\t\t\t\t\t\t} else if (!(textBeforeColonFound && colonFound && textAfterColonFound && commaAfterNameFound) &&\n\t\t\t\t\t\t\t\tinvalidTextRegex.test(sliced[0])) {\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t\tlastBreak -= 2;\n\t\t\t\t\t\t\t// no longer in a token\n\t\t\t\t\t\t\tinToken = false;\n\t\t\t\t\t\t\tif (level > 0) {\n\t\t\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// if we're at the beginning of another translation string,\n\t\t\t\t\t\t// we're nested, so add to our level\n\t\t\t\t\t\t} else if (sliced === '[[') {\n\t\t\t\t\t\t\tlevel += 1;\n\t\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t\t// if we're at the end of a translation string\n\t\t\t\t\t\t} else if (sliced === ']]') {\n\t\t\t\t\t\t\t// if we're at the base level, then this is the end\n\t\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t\t// so grab the name and args\n\t\t\t\t\t\t\t\tvar currentSlice = str.slice(lastBreak, cursor);\n\t\t\t\t\t\t\t\tvar result = split(currentSlice);\n\t\t\t\t\t\t\t\tvar name = result[0];\n\t\t\t\t\t\t\t\tvar args = result.slice(1);\n\n\t\t\t\t\t\t\t\t// make a backup based on the raw string of the token\n\t\t\t\t\t\t\t\t// if there are arguments to the token\n\t\t\t\t\t\t\t\tvar backup = '';\n\t\t\t\t\t\t\t\tif (args && args.length) {\n\t\t\t\t\t\t\t\t\tbackup = this.translate(currentSlice);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add the translation promise to the array\n\t\t\t\t\t\t\t\ttoTranslate.push(this.translateKey(name, args, backup));\n\t\t\t\t\t\t\t\t// skip past the ending brackets\n\t\t\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t\t\t\t// set this as our last break\n\t\t\t\t\t\t\t\tlastBreak = cursor;\n\t\t\t\t\t\t\t\t// and we're no longer in a translation string,\n\t\t\t\t\t\t\t\t// so continue with the main loop\n\t\t\t\t\t\t\t\tinToken = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// otherwise we lower the level\n\t\t\t\t\t\t\tlevel -= 1;\n\t\t\t\t\t\t\t// and skip past the ending brackets\n\t\t\t\t\t\t\tcursor += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise just move to the next character\n\t\t\t\t\t\t\tcursor += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// move to the next character\n\t\t\t\tcursor += 1;\n\t\t\t}\n\n\t\t\t// ending string of source\n\t\t\tvar last = str.slice(lastBreak);\n\n\t\t\t// if we were mid-token, treat it as invalid\n\t\t\tif (inToken) {\n\t\t\t\tlast = this.translate(last);\n\t\t\t}\n\n\t\t\t// add the remaining text after the last translation string\n\t\t\ttoTranslate.push(last);\n\n\t\t\t// and return a promise for the concatenated translated string\n\t\t\treturn Promise.all(toTranslate).then(function (translated) {\n\t\t\t\treturn translated.join('');\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Translates a specific key and array of arguments\n\t\t * @param {string} name - Translation key (ex. 'global:home')\n\t\t * @param {string[]} args - Arguments for `%1`, `%2`, etc\n\t\t * @param {string|Promise<string>} backup - Text to use in case the key can't be found\n\t\t * @returns {Promise<string>}\n\t\t */\n\t\tTranslator.prototype.translateKey = function translateKey(name, args, backup) {\n\t\t\tvar self = this;\n\n\t\t\tvar result = name.split(':', 2);\n\t\t\tvar namespace = result[0];\n\t\t\tvar key = result[1];\n\n\t\t\tif (self.modules[namespace]) {\n\t\t\t\treturn Promise.resolve(self.modules[namespace](key, args));\n\t\t\t}\n\n\t\t\tif (namespace && !key) {\n\t\t\t\twarn('Missing key in translation token \"' + name + '\"');\n\t\t\t\treturn Promise.resolve('[[' + namespace + ']]');\n\t\t\t}\n\n\t\t\tvar translation = this.getTranslation(namespace, key);\n\t\t\treturn translation.then(function (translated) {\n\t\t\t\t// check if the translation is missing first\n\t\t\t\tif (!translated) {\n\t\t\t\t\twarn('Missing translation \"' + name + '\"');\n\t\t\t\t\treturn backup || key;\n\t\t\t\t}\n\n\t\t\t\tvar argsToTranslate = args.map(function (arg) {\n\t\t\t\t\treturn string(arg).collapseWhitespace().decodeHTMLEntities().escapeHTML().s.replace(/&amp;/g, '&');\n\t\t\t\t}).map(function (arg) {\n\t\t\t\t\treturn self.translate(arg);\n\t\t\t\t});\n\n\t\t\t\treturn Promise.all(argsToTranslate).then(function (translatedArgs) {\n\t\t\t\t\tvar out = translated;\n\t\t\t\t\ttranslatedArgs.forEach(function (arg, i) {\n\t\t\t\t\t\tvar escaped = arg.replace(/%(?=\\d)/g, '&#37;').replace(/\\\\,/g, '&#44;');\n\t\t\t\t\t\tout = out.replace(new RegExp('%' + (i + 1), 'g'), escaped);\n\t\t\t\t\t});\n\t\t\t\t\treturn out;\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Load translation file (or use a cached version), and optionally return the translation of a certain key\n\t\t * @param {string} namespace - The file name of the translation namespace\n\t\t * @param {string} [key] - The key of the specific translation to getJSON\n\t\t * @returns {Promise<{ [key: string]: string }>|Promise<string>}\n\t\t */\n\t\tTranslator.prototype.getTranslation = function getTranslation(namespace, key) {\n\t\t\tvar translation;\n\t\t\tif (!namespace) {\n\t\t\t\twarn('[translator] Parameter `namespace` is ' + namespace + (namespace === '' ? '(empty string)' : ''));\n\t\t\t\ttranslation = Promise.resolve({});\n\t\t\t} else {\n\t\t\t\tthis.translations[namespace] = this.translations[namespace] || this.load(this.lang, namespace).catch(function () { return {}; });\n\t\t\t\ttranslation = this.translations[namespace];\n\t\t\t}\n\n\t\t\tif (key) {\n\t\t\t\treturn translation.then(function (x) {\n\t\t\t\t\treturn x[key];\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn translation;\n\t\t};\n\n\t\t/**\n\t\t * @param {Node} node\n\t\t * @returns {Node[]}\n\t\t */\n\t\tfunction descendantTextNodes(node) {\n\t\t\tvar textNodes = [];\n\n\t\t\tfunction helper(node) {\n\t\t\t\tif (node.nodeType === 3) {\n\t\t\t\t\ttextNodes.push(node);\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = 0, c = node.childNodes, l = c.length; i < l; i += 1) {\n\t\t\t\t\t\thelper(c[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelper(node);\n\t\t\treturn textNodes;\n\t\t}\n\n\t\t/**\n\t\t * Recursively translate a DOM element in place\n\t\t * @param {Element} element - Root element to translate\n\t\t * @param {string[]} [attributes] - Array of node attributes to translate\n\t\t * @returns {Promise<void>}\n\t\t */\n\t\tTranslator.prototype.translateInPlace = function translateInPlace(element, attributes) {\n\t\t\tattributes = attributes || ['placeholder', 'title'];\n\n\t\t\tvar nodes = descendantTextNodes(element);\n\t\t\tvar text = nodes.map(function (node) {\n\t\t\t\treturn node.nodeValue;\n\t\t\t}).join('  ||  ');\n\n\t\t\tvar attrNodes = attributes.reduce(function (prev, attr) {\n\t\t\t\tvar tuples = Array.prototype.map.call(element.querySelectorAll('[' + attr + '*=\"[[\"]'), function (el) {\n\t\t\t\t\treturn [attr, el];\n\t\t\t\t});\n\t\t\t\treturn prev.concat(tuples);\n\t\t\t}, []);\n\t\t\tvar attrText = attrNodes.map(function (node) {\n\t\t\t\treturn node[1].getAttribute(node[0]);\n\t\t\t}).join('  ||  ');\n\n\t\t\treturn Promise.all([\n\t\t\t\tthis.translate(text),\n\t\t\t\tthis.translate(attrText),\n\t\t\t]).then(function (ref) {\n\t\t\t\tvar translated = ref[0];\n\t\t\t\tvar translatedAttrs = ref[1];\n\t\t\t\tif (translated) {\n\t\t\t\t\ttranslated.split('  ||  ').forEach(function (html, i) {\n\t\t\t\t\t\t$(nodes[i]).replaceWith(html);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (translatedAttrs) {\n\t\t\t\t\ttranslatedAttrs.split('  ||  ').forEach(function (text, i) {\n\t\t\t\t\t\tattrNodes[i][1].setAttribute(attrNodes[i][0], text);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Get the language of the current environment, falling back to defaults\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.getLanguage = function getLanguage() {\n\t\t\tvar lang;\n\n\t\t\tif (typeof window === 'object' && window.config && window.utils) {\n\t\t\t\tlang = utils.params().lang || config.userLang || config.defaultLang || 'en-GB';\n\t\t\t} else {\n\t\t\t\tvar meta = require('../../../src/meta');\n\t\t\t\tlang = meta.config.defaultLang || 'en-GB';\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t};\n\n\t\t/**\n\t\t * Create and cache a new Translator instance, or return a cached one\n\t\t * @param {string} [language] - ('en-GB') Language string\n\t\t * @returns {Translator}\n\t\t */\n\t\tTranslator.create = function create(language) {\n\t\t\tif (!language) {\n\t\t\t\tlanguage = Translator.getLanguage();\n\t\t\t}\n\n\t\t\tTranslator.cache[language] = Translator.cache[language] || new Translator(language);\n\n\t\t\treturn Translator.cache[language];\n\t\t};\n\n\t\tTranslator.cache = {};\n\n\t\t/**\n\t\t * Register a custom module to handle translations\n\t\t * @param {string} namespace - Namespace to handle translation for\n\t\t * @param {Function} factory - Function to return the translation function for this namespace\n\t\t */\n\t\tTranslator.registerModule = function registerModule(namespace, factory) {\n\t\t\tTranslator.moduleFactories[namespace] = factory;\n\n\t\t\tObject.keys(Translator.cache).forEach(function (key) {\n\t\t\t\tvar translator = Translator.cache[key];\n\t\t\t\ttranslator.modules[namespace] = factory(translator.lang);\n\t\t\t});\n\t\t};\n\n\t\tTranslator.moduleFactories = {};\n\n\t\t/**\n\t\t * Remove the translator patterns from text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.removePatterns = function removePatterns(text) {\n\t\t\tvar len = text.length;\n\t\t\tvar cursor = 0;\n\t\t\tvar lastBreak = 0;\n\t\t\tvar level = 0;\n\t\t\tvar out = '';\n\t\t\tvar sub;\n\n\t\t\twhile (cursor < len) {\n\t\t\t\tsub = text.slice(cursor, cursor + 2);\n\t\t\t\tif (sub === '[[') {\n\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\tout += text.slice(lastBreak, cursor);\n\t\t\t\t\t}\n\t\t\t\t\tlevel += 1;\n\t\t\t\t\tcursor += 2;\n\t\t\t\t} else if (sub === ']]') {\n\t\t\t\t\tlevel -= 1;\n\t\t\t\t\tcursor += 2;\n\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\tlastBreak = cursor;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcursor += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout += text.slice(lastBreak, cursor);\n\t\t\treturn out;\n\t\t};\n\n\t\t/**\n\t\t * Escape translator patterns in text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.escape = function escape(text) {\n\t\t\treturn typeof text === 'string' ? text.replace(/\\[\\[/g, '&lsqb;&lsqb;').replace(/\\]\\]/g, '&rsqb;&rsqb;') : text;\n\t\t};\n\n\t\t/**\n\t\t * Unescape escaped translator patterns in text\n\t\t * @param {string} text\n\t\t * @returns {string}\n\t\t */\n\t\tTranslator.unescape = function unescape(text) {\n\t\t\treturn typeof text === 'string' ? text.replace(/&lsqb;|\\\\\\[/g, '[').replace(/&rsqb;|\\\\\\]/g, ']') : text;\n\t\t};\n\n\t\t/**\n\t\t * Construct a translator pattern\n\t\t * @param {string} name - Translation name\n\t\t * @param {...string} arg - Optional argument for the pattern\n\t\t */\n\t\tTranslator.compile = function compile() {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 0).map(function (text) {\n\t\t\t\t// escape commas and percent signs in arguments\n\t\t\t\treturn text.replace(/%/g, '&#37;').replace(/,/g, '&#44;');\n\t\t\t});\n\n\t\t\treturn '[[' + args.join(', ') + ']]';\n\t\t};\n\n\t\treturn Translator;\n\t}());\n\n\t/**\n\t * @exports translator\n\t */\n\tvar adaptor = {\n\t\t/**\n\t\t * The Translator class\n\t\t */\n\t\tTranslator: Translator,\n\n\t\tcompile: Translator.compile,\n\t\tescape: Translator.escape,\n\t\tunescape: Translator.unescape,\n\t\tgetLanguage: Translator.getLanguage,\n\n\t\t/**\n\t\t * Legacy translator function for backwards compatibility\n\t\t */\n\t\ttranslate: function translate(text, language, callback) {\n\t\t\t// TODO: deprecate?\n\n\t\t\tvar cb = callback;\n\t\t\tvar lang = language;\n\t\t\tif (typeof language === 'function') {\n\t\t\t\tcb = language;\n\t\t\t\tlang = null;\n\t\t\t}\n\n\t\t\tif (!(typeof text === 'string' || text instanceof String) || text === '') {\n\t\t\t\treturn cb('');\n\t\t\t}\n\n\t\t\tTranslator.create(lang).translate(text).catch(function (err) {\n\t\t\t\twarn('Translation failed: ' + err.stack);\n\t\t\t}).then(function (output) {\n\t\t\t\tcb(output);\n\t\t\t}).catch(function (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Add translations to the cache\n\t\t */\n\t\taddTranslation: function addTranslation(language, namespace, translation) {\n\t\t\tTranslator.create(language).getTranslation(namespace).then(function (translations) {\n\t\t\t\tassign(translations, translation);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Get the translations object\n\t\t */\n\t\tgetTranslations: function getTranslations(language, namespace, callback) {\n\t\t\tcallback = callback || function () {};\n\t\t\tTranslator.create(language).getTranslation(namespace).then(callback);\n\t\t},\n\n\t\t/**\n\t\t * Alias of getTranslations\n\t\t */\n\t\tload: function load(language, namespace, callback) {\n\t\t\tadaptor.getTranslations(language, namespace, callback);\n\t\t},\n\n\t\ttoggleTimeagoShorthand: function toggleTimeagoShorthand() {\n\t\t\tvar tmp = assign({}, jQuery.timeago.settings.strings);\n\t\t\tjQuery.timeago.settings.strings = assign({}, adaptor.timeagoShort);\n\t\t\tadaptor.timeagoShort = assign({}, tmp);\n\t\t},\n\t\tprepareDOM: function prepareDOM() {\n\t\t\t// Load the appropriate timeago locale file,\n\t\t\t// and correct NodeBB language codes to timeago codes, if necessary\n\t\t\tvar languageCode = utils.userLangToTimeagoCode(config.userLang);\n\n\t\t\tadaptor.timeagoShort = assign({}, jQuery.timeago.settings.strings);\n\n\t\t\tjQuery.getScript(config.relative_path + '/assets/vendor/jquery/timeago/locales/jquery.timeago.' + languageCode + '-short.js').done(function () {\n\t\t\t\t// Switch back to long-form\n\t\t\t\tadaptor.toggleTimeagoShorthand();\n\t\t\t});\n\n\t\t\t// Add directional code if necessary\n\t\t\tadaptor.translate('[[language:dir]]', function (value) {\n\t\t\t\tif (value && !$('html').attr('data-dir')) {\n\t\t\t\t\tjQuery('html').css('direction', value).attr('data-dir', value);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t};\n\n\treturn adaptor;\n}));\n"]}